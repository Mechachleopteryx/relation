#lang racket/base

(module+ test
  (require rackunit)
  (require racket/set)
  (require racket/stream)
  (require (prefix-in f: racket/function)))

;; Code here

(require "comparable.rkt"
         "transform.rkt"
         "algebraic.rkt")

(provide (all-from-out "comparable.rkt"
                       "transform.rkt"
                       "algebraic.rkt"))

(module+ test
  ;; Any code in this `test` submodule runs when this file is run using DrRacket
  ;; or with `raco test`. The code here does not run when this file is
  ;; required by another module.

  ;; Equivalence types:
  ;;   - any
  ;; Order types:
  ;;   - numbers
  ;;   - characters
  ;;   - strings
  ;;   - byte strings
  ;;   - sets

  ;;; comparable
  ;; less than
  (check-true (< 1 2 3) "monotonically increasing")
  (check-false (< 1 1 2) "monotonically nondecreasing")
  (check-false (< 3 3 3) "equal")
  (check-false (< 3 3 1) "monotonically nonincreasing")
  (check-false (< 3 2 1) "monotonically decreasing")
  (check-false (< 3 2 4) "disordered")
  (check-true (< 3) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (<)) "generic relations require at least one argument")
  (check-true (< "apple" "banana" "cherry"))
  (check-false (< "apple" "apple" "apple"))
  (check-false (< "cherry" "banana" "apple"))
  (check-true (< #"apple" #"banana" #"cherry"))
  (check-false (< #"apple" #"apple" #"apple"))
  (check-false (< #"cherry" #"banana" #"apple"))
  (check-true (< #\a #\b #\c))
  (check-false (< #\a #\a #\a))
  (check-false (< #\c #\b #\a))
  (check-true (< (set) (set 1) (set 1 2)))
  (check-false (< (set 1 2) (set 1 2) (set 1 2)))
  (check-false (< (set 1 2) (set 1) (set)))
  (check-false (< (set 1 2) (set 1 3)) "incomparable sets")
  (check-false (< (set 1 2) (set 3 4)) "incomparable sets")
  (check-true (< #:key string-length "z" "yy" "xxx"))
  (check-false (< #:key string-length "xxx" "zzz" "yyy"))
  (check-false (< #:key string-length "xxx" "yy" "z"))

  ;; less than or equal to
  (check-true (<= 1 2 3) "monotonically increasing")
  (check-true (<= 1 1 2) "monotonically nondecreasing")
  (check-true (<= 3 3 3) "equal")
  (check-false (<= 3 3 1) "monotonically nonincreasing")
  (check-false (<= 3 2 1) "monotonically decreasing")
  (check-false (<= 3 2 4) "disordered")
  (check-true (<= 3) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (<=)) "generic relations require at least one argument")
  (check-true (<= "apple" "banana" "cherry"))
  (check-true (<= "apple" "apple" "apple"))
  (check-false (<= "cherry" "banana" "apple"))
  (check-true (<= #"apple" #"banana" #"cherry"))
  (check-true (<= #"apple" #"apple" #"apple"))
  (check-false (<= #"cherry" #"banana" #"apple"))
  (check-true (<= #\a #\b #\c))
  (check-true (<= #\a #\a #\a))
  (check-false (<= #\c #\b #\a))
  (check-true (<= (set) (set 1) (set 1 2)))
  (check-true (<= (set 1 2) (set 1 2) (set 1 2)))
  (check-false (<= (set 1 2) (set 1) (set)))
  (check-false (<= (set 1 2) (set 1 3)) "incomparable sets")
  (check-false (<= (set 1 2) (set 3 4)) "incomparable sets")
  (check-true (<= #:key string-length "z" "yy" "xxx"))
  (check-true (<= #:key string-length "xxx" "zzz" "yyy"))
  (check-false (<= #:key string-length "xxx" "yy" "z"))
  (check-true (≤ 2 3))
  (check-false (≤ 3 2))

  ;; equal / equivalence
  (check-false (= 1 2 3) "monotonically increasing")
  (check-false (= 1 1 2) "monotonically nondecreasing")
  (check-true (= 3 3 3) "equal")
  (check-false (= 3 3 1) "monotonically nonincreasing")
  (check-false (= 3 2 1) "monotonically decreasing")
  (check-false (= 3 2 4) "disordered")
  (check-true (= 3) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (=)) "generic relations require at least one argument")
  (check-false (= "apple" "banana" "cherry"))
  (check-true (= "apple" "apple" "apple"))
  (check-false (= "cherry" "banana" "apple"))
  (check-false (= #"apple" #"banana" #"cherry"))
  (check-true (= #"apple" #"apple" #"apple"))
  (check-false (= #"cherry" #"banana" #"apple"))
  (check-false (= #\a #\b #\c))
  (check-true (= #\a #\a #\a))
  (check-false (= #\c #\b #\a))
  (check-false (= (set) (set 1) (set 1 2)))
  (check-true (= (set 1 2) (set 1 2) (set 1 2)))
  (check-false (= (set 1 2) (set 1) (set)))
  (check-false (= (set 1 2) (set 1 3)) "incomparable sets")
  (check-false (= (set 1 2) (set 3 4)) "incomparable sets")
  (check-false (= #:key string-length "z" "yy" "xxx"))
  (check-true (= #:key string-length "xxx" "zzz" "yyy"))
  (check-false (= #:key string-length "xxx" "yy" "z"))

  ;; simple type-specific equality
  (check-true (= "banana" "banana"))
  (check-true (= #"banana" #"banana"))
  (check-true (= #\a #\a))
  (check-true (= (set 1) (set 1) (set 1)))
  (check-true (= 'hi 'hi 'hi))

  ;; equivalence under a mapping
  (check-true (= #:key f:identity 1 1 1))
  (check-true (= #:key even? 1 13 7))
  (check-true (= #:key even? 2 14 8))
  (check-false (= #:key even? 2 3))
  (check-true (= #:key string-upcase "apple" "Apple" "APPLE"))
  (check-true (= #:key ->number "42" "42.0" "42/1"))
  (check-false (= #:key ->number "42" "42.1"))

  ;; greater than or equal to
  (check-false (>= 1 2 3) "monotonically increasing")
  (check-false (>= 1 1 2) "monotonically nondecreasing")
  (check-true (>= 3 3 3) "equal")
  (check-true (>= 3 3 1) "monotonically nonincreasing")
  (check-true (>= 3 2 1) "monotonically decreasing")
  (check-false (>= 3 2 4) "disordered")
  (check-true (>= 3) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (>=)) "generic relations require at least one argument")
  (check-false (>= "apple" "banana" "cherry"))
  (check-true (>= "apple" "apple" "apple"))
  (check-true (>= "cherry" "banana" "apple"))
  (check-false (>= #"apple" #"banana" #"cherry"))
  (check-true (>= #"apple" #"apple" #"apple"))
  (check-true (>= #"cherry" #"banana" #"apple"))
  (check-false (>= #\a #\b #\c))
  (check-true (>= #\a #\a #\a))
  (check-true (>= #\c #\b #\a))
  (check-false (>= (set) (set 1) (set 1 2)))
  (check-true (>= (set 1 2) (set 1 2) (set 1 2)))
  (check-true (>= (set 1 2) (set 1) (set)))
  (check-false (>= (set 1 2) (set 1 3)) "incomparable sets")
  (check-false (>= (set 1 2) (set 3 4)) "incomparable sets")
  (check-false (>= #:key string-length "z" "yy" "xxx"))
  (check-true (>= #:key string-length "xxx" "zzz" "yyy"))
  (check-true (>= #:key string-length "xxx" "yy" "z"))
  (check-false (≥ 2 3))
  (check-true (≥ 3 2))

  ;; greater than
  (check-false (> 1 2 3) "monotonically increasing")
  (check-false (> 1 1 2) "monotonically nondecreasing")
  (check-false (> 3 3 3) "equal")
  (check-false (> 3 3 1) "monotonically nonincreasing")
  (check-true (> 3 2 1) "monotonically decreasing")
  (check-false (> 3 2 4) "disordered")
  (check-true (> 3) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (>)) "generic relations require at least one argument")
  (check-false (> "apple" "banana" "cherry"))
  (check-false (> "apple" "apple" "apple"))
  (check-true (> "cherry" "banana" "apple"))
  (check-false (> #"apple" #"banana" #"cherry"))
  (check-false (> #"apple" #"apple" #"apple"))
  (check-true (> #"cherry" #"banana" #"apple"))
  (check-false (> #\a #\b #\c))
  (check-false (> #\a #\a #\a))
  (check-true (> #\c #\b #\a))
  (check-false (> (set) (set 1) (set 1 2)))
  (check-false (> (set 1 2) (set 1 2) (set 1 2)))
  (check-true (> (set 1 2) (set 1) (set)))
  (check-false (> (set 1 2) (set 1 3)) "incomparable sets")
  (check-false (> (set 1 2) (set 3 4)) "incomparable sets")
  (check-false (> #:key string-length "z" "yy" "xxx"))
  (check-false (> #:key string-length "xxx" "zzz" "yyy"))
  (check-true (> #:key string-length "xxx" "yy" "z"))

  ;; not equal
  (check-true (/= 1 2 3) "monotonically increasing")
  (check-true (/= 1 1 2) "monotonically nondecreasing")
  (check-false (/= 3 3 3) "equal")
  (check-true (/= 3 3 1) "monotonically nonincreasing")
  (check-true (/= 3 2 1) "monotonically decreasing")
  (check-true (/= 3 2 4) "disordered")
  (check-false (/= 3) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (/=)) "generic relations require at least one argument")
  (check-true (/= "apple" "banana" "cherry"))
  (check-false (/= "apple" "apple" "apple"))
  (check-true (/= "cherry" "banana" "apple"))
  (check-true (/= #"apple" #"banana" #"cherry"))
  (check-false (/= #"apple" #"apple" #"apple"))
  (check-true (/= #"cherry" #"banana" #"apple"))
  (check-true (/= #\a #\b #\c))
  (check-false (/= #\a #\a #\a))
  (check-true (/= #\c #\b #\a))
  (check-true (/= (set) (set 1) (set 1 2)))
  (check-false (/= (set 1 2) (set 1 2) (set 1 2)))
  (check-true (/= (set 1 2) (set 1) (set)))
  (check-true (/= (set 1 2) (set 1 3)) "incomparable sets")
  (check-true (/= (set 1 2) (set 3 4)) "incomparable sets")
  (check-true (/= #:key string-length "z" "yy" "xxx"))
  (check-false (/= #:key string-length "xxx" "zzz" "yyy"))
  (check-true (/= #:key string-length "xxx" "yy" "z"))
  (check-false (≠ 2 2))
  (check-true (≠ 3 2))

  (check-true (/= "apple" "Apple"))
  (check-true (/= 'a 'b))
  (check-false (/= 'a 'a))

  ;; min
  (check-equal? (min 1 2 3) 1 "monotonically increasing")
  (check-equal? (min 1 1 2) 1 "monotonically nondecreasing")
  (check-equal? (min 3 3 3) 3 "equal")
  (check-equal? (min 3 3 1) 1 "monotonically nonincreasing")
  (check-equal? (min 3 2 1) 1 "monotonically decreasing")
  (check-equal? (min 3 2 4) 2 "disordered")
  (check-equal? (min 3) 3 "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (min)) "generic relations require at least one argument")
  (check-equal? (min "apple" "banana" "cherry") "apple")
  (check-equal? (min "apple" "apple" "apple") "apple")
  (check-equal? (min "cherry" "banana" "apple") "apple")
  (check-equal? (min #"apple" #"banana" #"cherry") #"apple")
  (check-equal? (min #"apple" #"apple" #"apple") #"apple")
  (check-equal? (min #"cherry" #"banana" #"apple") #"apple")
  (check-equal? (min #\a #\b #\c) #\a)
  (check-equal? (min #\a #\a #\a) #\a)
  (check-equal? (min #\c #\b #\a) #\a)
  (check-equal? (min (set) (set 1) (set 1 2)) (set))
  (check-equal? (min (set 1 2) (set 1 2) (set 1 2)) (set 1 2))
  (check-equal? (min (set 1 2) (set 1) (set)) (set))
  ;(check-equal? (min (set 1 2) (set 1 3)) "incomparable sets")
  ;(check-equal? (min (set 1 2) (set 3 4)) "incomparable sets")
  (check-equal? (min #:key string-length "z" "yy" "xxx") "z")
  (check memq (min #:key string-length "xxx" "zzz" "yyy") '("xxx" "yyy" "zzz"))
  (check-equal? (min #:key string-length "xxx" "yy" "z") "z")

  ;; max
  (check-equal? (max 1 2 3) 3 "monotonically increasing")
  (check-equal? (max 1 1 2) 2 "monotonically nondecreasing")
  (check-equal? (max 3 3 3) 3 "equal")
  (check-equal? (max 3 3 1) 3 "monotonically nonincreasing")
  (check-equal? (max 3 2 1) 3 "monotonically decreasing")
  (check-equal? (max 3 2 4) 4 "disordered")
  (check-equal? (max 3) 3 "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (max)) "generic relations require at least one argument")
  (check-equal? (max "apple" "banana" "cherry") "cherry")
  (check-equal? (max "apple" "apple" "apple") "apple")
  (check-equal? (max "cherry" "banana" "apple") "cherry")
  (check-equal? (max #"apple" #"banana" #"cherry") #"cherry")
  (check-equal? (max #"apple" #"apple" #"apple") #"apple")
  (check-equal? (max #"cherry" #"banana" #"apple") #"cherry")
  (check-equal? (max #\a #\b #\c) #\c)
  (check-equal? (max #\a #\a #\a) #\a)
  (check-equal? (max #\c #\b #\a) #\c)
  (check-equal? (max (set) (set 1) (set 1 2)) (set 1 2))
  (check-equal? (max (set 1 2) (set 1 2) (set 1 2)) (set 1 2))
  (check-equal? (max (set 1 2) (set 1) (set)) (set 1 2))
  ;(check-equal? (max (set 1 2) (set 1 3)) "incomparable sets")
  ;(check-equal? (max (set 1 2) (set 3 4)) "incomparable sets")
  (check-equal? (max #:key string-length "z" "yy" "xxx") "xxx")
  (check memq (max #:key string-length "xxx" "zzz" "yyy") '("xxx" "yyy" "zzz"))
  (check-equal? (max #:key string-length "xxx" "yy" "z") "xxx")

  ;; =/classes
  (check-equal? (=/classes (list 1 2 3)) '((1) (2) (3)) "monotonically increasing")
  (check-equal? (=/classes (list 1 1 2)) '((1 1) (2)) "monotonically nondecreasing")
  (check-equal? (=/classes (list 3 3 3)) '((3 3 3)) "equal")
  (check-equal? (=/classes (list 3 3 1)) '((1) (3 3)) "monotonically nonincreasing")
  (check-equal? (=/classes (list 3 2 1)) '((1) (2) (3)) "monotonically decreasing")
  (check-equal? (=/classes (list 3 2 4)) '((2) (3) (4)) "disordered")
  (check-equal? (=/classes (list 3)) '((3)) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (=/classes)) "generic relations require at least one argument")
  (check-equal? (=/classes (list "apple" "banana" "cherry")) '(("apple") ("banana") ("cherry")))
  (check-equal? (=/classes (list "apple" "apple" "apple")) '(("apple" "apple" "apple")))
  (check-equal? (=/classes (list "cherry" "banana" "apple")) '(("apple") ("banana") ("cherry")))
  (check-equal? (=/classes (list #"apple" #"banana" #"cherry")) '((#"apple") (#"banana") (#"cherry")))
  (check-equal? (=/classes (list #"apple" #"apple" #"apple")) '((#"apple" #"apple" #"apple")))
  (check-equal? (=/classes (list #"cherry" #"banana" #"apple")) '((#"apple") (#"banana") (#"cherry")))
  (check-equal? (=/classes (list #\a #\b #\c)) '((#\a) (#\b) (#\c)))
  (check-equal? (=/classes (list #\a #\a #\a)) '((#\a #\a #\a)))
  (check-equal? (=/classes (list #\c #\b #\a)) '((#\a) (#\b) (#\c)))
  (check-equal? (=/classes (list (set) (set 1) (set 1 2))) (list (list (set)) (list (set 1)) (list (set 1 2))))
  (check-equal? (=/classes (list (set 1 2) (set 1 2) (set 1 2))) (list (list (set 1 2) (set 1 2) (set 1 2))))
  (check-equal? (=/classes (list (set 1 2) (set 1) (set))) (list (list (set)) (list (set 1)) (list (set 1 2))))
  (check-equal? (=/classes (list (set 1 2) (set 1 3))) (list (list (set 1 2)) (list (set 1 3))) "incomparable sets")
  (check-equal? (=/classes (list (set 1 2) (set 3 4))) (list (list (set 1 2)) (list (set 3 4))) "incomparable sets")
  (check-equal? (=/classes #:key string-length (list "z" "yy" "xxx")) '(("z") ("yy") ("xxx")))
  (check-equal? (=/classes #:key string-length (list "xxx" "zzz" "yyy")) '(("xxx" "zzz" "yyy")))
  (check-equal? (=/classes #:key string-length (list "xxx" "yy" "z")) '(("z") ("yy") ("xxx")))

  ;; set
  (check-equal? (->list (generic-set 1 2 3)) '(1 2 3) "monotonically increasing")
  (check-equal? (->list (generic-set 1 1 2)) '(1 2) "monotonically nondecreasing")
  (check-equal? (->list (generic-set 3 3 3)) '(3) "equal")
  (check-equal? (->list (generic-set 3 3 1)) '(1 3) "monotonically nonincreasing")
  (check-equal? (->list (generic-set 3 2 1)) '(1 2 3) "monotonically decreasing")
  (check-equal? (->list (generic-set 3 2 4)) '(2 3 4) "disordered")
  (check-equal? (->list (generic-set 3)) '(3) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (generic-set)) "generic relations require at least one argument")
  (check-equal? (->list (generic-set "apple" "banana" "cherry")) '("apple" "banana" "cherry"))
  (check-equal? (->list (generic-set "apple" "apple" "apple")) '("apple"))
  (check-equal? (->list (generic-set "cherry" "banana" "apple")) '("apple" "banana" "cherry"))
  (check-equal? (->list (generic-set #"apple" #"banana" #"cherry")) '(#"apple" #"banana" #"cherry"))
  (check-equal? (->list (generic-set #"apple" #"apple" #"apple")) '(#"apple"))
  (check-equal? (->list (generic-set #"cherry" #"banana" #"apple")) '(#"apple" #"banana" #"cherry"))
  (check-equal? (->list (generic-set #\a #\b #\c)) '(#\a #\b #\c))
  (check-equal? (->list (generic-set #\a #\a #\a)) '(#\a))
  (check-equal? (->list (generic-set #\c #\b #\a)) '(#\a #\b #\c))
  (check-equal? (->list (generic-set (set) (set 1) (set 1 2))) (list (set) (set 1) (set 1 2)))
  (check-equal? (->list (generic-set (set 1 2) (set 1 2) (set 1 2))) (list (set 1 2)))
  (check-equal? (->list (generic-set (set 1 2) (set 1) (set))) (list (set) (set 1) (set 1 2)))
  (check-equal? (->list (generic-set (set 1 2) (set 1 3))) (list (set 1 2) (set 1 3)) "incomparable sets")
  (check-equal? (->list (generic-set (set 1 2) (set 3 4))) (list (set 1 2) (set 3 4)) "incomparable sets")
  (check-equal? (->list (generic-set #:key string-length "z" "yy" "xxx")) '("z" "yy" "xxx"))
  (check-equal? (->list (generic-set #:key string-length "xxx" "zzz" "yyy")) '("xxx"))
  (check-equal? (->list (generic-set #:key string-length "xxx" "yy" "z")) '("z" "yy" "xxx"))

  ;;; transform
  (check-true (->boolean 0))
  (check-false (->boolean #f))
  (check-equal? (->string 123) "123")
  (check-equal? (->string '(#\a #\p #\p #\l #\e)) "apple")
  (check-equal? (->string '(1 2 3)) "(1 2 3)")
  (check-equal? (->number "123") 123)
  (check-equal? (->number #\a) 97)
  (check-equal? (->inexact 3/2) 1.5)
  (check-equal? (->inexact 3) 3.0)
  (check-equal? (->exact 1.5) 3/2)
  (check-equal? (->exact 1.0) 1)
  (check-equal? (->integer 1.5) 1)
  (check-equal? (->integer 1.3 #:round 'up) 2)
  (check-equal? (->integer 1.6 #:round 'down) 1)
  (check-equal? (->integer 1.6 #:round 'nearest) 2)
  (check-equal? (->integer #\a) 97)
  (check-equal? (->integer "123") 123)
  (check-equal? (->list "abc") (list #\a #\b #\c))
  (check-equal? (->list #(1 2 3)) (list 1 2 3))
  (check-equal? (->list (hash 'a 1)) (list (cons 'a 1)))
  (check-equal? (->list (set 'a)) (list 'a))
  (check-equal? (->vector (list 1 2 3)) #(1 2 3))
  (check-equal? (->vector "abc") #(#\a #\b #\c))
  (check-equal? (->symbol "abc") 'abc)
  (check-equal? (->keyword "abc") '#:abc)
  (check-equal? (->bytes (list 97 98 99)) #"abc")
  (check-equal? (->bytes "abc") #"abc")
  (check-equal? (->char 97) #\a)
  (check-equal? (->char "a") #\a)
  (check-equal? (->char '("a")) #\a)
  (check-equal? (->char 'a) #\a)
  (check-equal? (stream-first (->stream (list 1 2 3))) 1)
  (check-equal? (stream-first (->stream "apple")) #\a)
  (check-equal? (set-count (->set (list 1 2 3 1))) 3)
  (check-equal? (set-count (->set "apple")) 4)
  (check-equal? (->code (->syntax (list 1 2 3))) '(1 2 3))
  (check-equal? (let-values ([(a b c) (->values (list 1 2 3))])
                  (list a b c)) (list 1 2 3))
  ;; failure cases
  (check-exn exn:fail?
             (lambda ()
               (->number 'hi)))
  (check-exn exn:fail?
             (lambda ()
               (->number '(1 2 3))))
  (check-exn exn:fail?
             (lambda ()
               (->inexact 'hi)))
  (check-exn exn:fail?
             (lambda ()
               (->inexact '(1 2 3))))
  (check-exn exn:fail?
             (lambda ()
               (->exact 'hi)))
  (check-exn exn:fail?
             (lambda ()
               (->exact '(1 2 3))))
  (check-exn exn:fail?
             (lambda ()
               (->integer 'hi)))
  (check-exn exn:fail?
             (lambda ()
               (->integer '(1 2 3))))
  (check-exn exn:fail?
             (lambda ()
               (->list eval)))
  (check-exn exn:fail?
             (lambda ()
               (->vector eval)))
  (check-exn exn:fail?
             (lambda ()
               (->bytes "λ")))
  (check-exn exn:fail?
             (lambda ()
               (->char '(1 2 3))))
  (check-exn exn:fail?
             (lambda ()
               (->stream 'hi)))
  (check-exn exn:fail?
             (lambda ()
               (->set 'hi)))
  (check-exn exn:fail?
             (lambda ()
               (->values 'hi)))

  ;;; algebraic
  ;; elementary composition
  (check-equal? (>< 1 2) (cons 1 2))
  (check-equal? (>< "a" "b") (cons "a" "b"))
  (check-equal? (>< 1 "a") (cons 1 "a"))
  (check-equal? (>< 1 '(2 3)) '(1 2 3))
  ;; associative composition
  (check-equal? (.. 3 4) 12)
  (check-equal? (.. "hi" " " "there") "hi there")
  (check-equal? (.. #"hi" #" " #"there") #"hi there")
  (check-equal? (.. '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6))
  (check-equal? (.. #(1 2 3) #(4 5 6)) #(1 2 3 4 5 6))
  (check-equal? (set-count (.. (set 1 2 3) (set 3 4 5))) 5)
  ;; TODO: why doesn't this work?
  ;; (check-equal? (.. (hash 'a 1 'b 2) (hash 'c 3)) (hash 'a 1 'b 2 'c 3))
  (check-equal? (->list (.. (stream 1 2 3) (stream 4 5 6))) (list 1 2 3 4 5 6))
  (check-equal? ((.. ->string +) 3 4) "7")
  ;; identity
  (check-equal? (identity 3 +) 0)
  (check-equal? (identity -3 +) 0)
  (check-equal? (identity 3 *) 1)
  (check-equal? (identity -3 *) 1)
  (check-equal? (identity #(1 -2) +) #(0 0))
  (check-equal? (identity #(1 -2) ..) #())
  (check-equal? (identity + ..) f:identity)
  (check-equal? (identity "hello" ..) "")
  (check-equal? (identity #"hello" ..) #"")
  (check-equal? (identity '(1 2 3) ..) '())
  (check-equal? (identity (set 1 2 3) ..) (set))
  (check-equal? (identity (hash 'a 1 'b 2 'c 3) ..) (hash))
  (check-equal? (identity (stream 1 2 3) ..) (list))
  ;; addition
  (check-equal? (+ 97 3) 100)
  (check-equal? (->vector (+ #(1 2 3) #(1 2 3) #(1 2 3))) #(3 6 9))
  ;; group inverse
  (check-equal? (inverse 3 +) -3)
  (check-equal? (inverse #(1 2) +) #(-1 -2))
  (check-equal? (inverse #(1 -2 3) +) #(-1 2 -3))
  (let ([x 3])
    (check-equal? (+ x (inverse x +))
                  (identity x +)))
  (let ([x #(1 -2 3)])
    (check-equal? (+ x (inverse x +))
                  (identity x +)))
  (let ([x 3])
    (check-equal? (* x (inverse x *))
                  (identity x *)))
  ;; "subtraction" on groups
  (check-equal? (- 4 3) 1)
  (check-equal? (- 4 6) -2)
  (check-equal? (- #(1 2) #(1 2)) #(0 0))
  (check-equal? (- #(1 2) #(-1 3)) #(2 -1))
  (check-equal? (- #(1 2 3) #(1 0 0) #(0 2 1)) #(0 0 2))
  (check-equal? (- 1) -1 "subtraction with single arg returns inverse")
  (check-equal? (- #(1 -2)) #(-1 2) "subtraction with single arg returns inverse")
  ;; fold
  (check-equal? (foldr + '(1 2 3 4)) 10)
  (check-equal? (foldr * '(1 2 3 4)) 24)
  (check-equal? (foldl + '(1 2 3 4)) 10)
  (check-equal? (foldl * '(1 2 3 4)) 24)
  (check-equal? (fold + '(1 2 3 4)) 10)
  (check-equal? (foldr cons '(1 2 3) '()) '(1 2 3))
  (check-equal? (foldl cons '(1 2 3) '()) '(3 2 1)))

(module+ main
  ;; (Optional) main submodule. Put code here if you need it to be executed when
  ;; this file is run using DrRacket or the `racket` executable.  The code here
  ;; does not run when this file is required by another module. Documentation:
  ;; http://docs.racket-lang.org/guide/Module_Syntax.html#%28part._main-and-test%29

  (require racket/cmdline)
  (define who (box "world"))
  (command-line
    #:program "my-program"
    #:once-each
    [("-n" "--name") name "Who to say hello to" (set-box! who name)]
    #:args ()
    (printf "hello ~a~n" (unbox who))))
