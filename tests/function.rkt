#lang racket/base

(module+ test
  (require rackunit
           racket/stream
           racket/bool
           (except-in data/collection
                      foldl
                      foldl/steps
                      append)
           data/maybe
           (only-in racket/function
                    thunk
                    const)
           arguments
           relation)

  ;; TODO: different compositions, curry, evaluate coverage
  (check-equal? ((unthunk (λ () 5))) 5)
  (check-equal? ((unthunk (λ () 5)) 1) 5)
  (check-equal? ((unthunk (λ () 5)) 1 2 3) 5)
  (check-equal? ((unthunk (λ (v) v) 5) 1 2 3) 5)
  (check-equal? ((unthunk (λ (a b) (+ a b)) 5 4) 1 2 3) 9)
  (check-equal? (andf 1 2 3) (and 1 2 3))
  (check-equal? (andf 1 #f 3) (and 1 #f 3))
  (check-equal? (andf #f #t) (and #f #t))
  (check-equal? (andf #t #t) (and #t #t))
  (check-equal? (orf 1 2 3) (or 1 2 3))
  (check-equal? (orf 1 #f 3) (or 1 #f 3))
  (check-equal? (orf #f #t) (or #f #t))
  (check-equal? (orf #t #t) (or #t #t))
  (check-equal? ((flip string-append) " " "hello" "my" " " "friend") "hello my friend")
  (check-equal? ((flip$ string-append) "friend" "hello" " " "my" " ") "hello my friend")
  (check-equal? ((flip* string-append) "friend" " " "my" " " "hello") "hello my friend")
  (check-equal? (->list ((lift add1) (list 1 2 3))) (list 2 3 4))
  (check-equal? (->list ((lift ->string) (list 1 2 3))) (list "1" "2" "3"))
  (check-equal? ((lift add1) (just 3)) (just 4))
  (check-equal? ((make-function add1 add1 +) 3 2) 7)
  (check-equal? ((make-function +) 3 2) 5)
  (check-equal? (first (make-function add1 sub1)) add1)
  (check-equal? (second (make-function add1 sub1)) sub1)
  (check-true (empty? (make-function)))
  (let ([str-append-3 (procedure-reduce-arity string-append 3)])
    (check-equal? ((curry str-append-3 "hello") " " "there") "hello there")
    (check-equal? (((curry str-append-3 "hello") " ") "there") "hello there")
    (check-equal? ((curry str-append-3 "hello" " ") "there") "hello there")
    (check-equal? ((curryr str-append-3 "there") "hello" " ") "hello there")
    (check-equal? (((curryr str-append-3 "there") " ") "hello") "hello there")
    (check-equal? ((curryr str-append-3 " " "there") "hello") "hello there")
    (check-equal? (length (arguments-positional (function-args (((curryr str-append-3 "there") " "))))) 2 "invoking with incomplete args")
    (check-equal? ((function-cons ->bytes (curry str-append-3 "hello" " ")) "there") #"hello there")
    (check-exn exn:fail:contract:arity? (thunk ((curry str-append-3 "hello" "there") "blah" "blah")))
    (check-exn exn:fail:contract:arity? (thunk ((curry str-append-3 "hello" "there" "blah") "blah")))
    (check-exn exn:fail:contract:arity? (thunk ((curry str-append-3 "hello") "there" "blah" "blah")))
    (check-exn exn:fail:contract:arity? (thunk ((curry str-append-3 "hello" "there" "blah" "blah")))))
  (check-equal? ((function-cons add1 (f sub1)) 3) 3)
  (check-equal? (->list (apply/steps (f add1 sub1 add1) (list 3))) (list 4 3 4))
  (check-equal? (->list (apply/steps (f ->string sub1 fold) #:into 2 + (list (list 1 2 3 4)))) (list 12 11 "11"))
  (check-equal? ((compose add1 sub1) 3) 3)
  (check-equal? ((compose (f add1) (f sub1)) 3) 3)
  (check-equal? ((compose (f add1) (curry + 2)) 3) 6)
  (check-equal? ((power 3 add1) 3) 6)
  (check-equal? ((power 1 add1) 3) 4)
  (check-equal? ((power 0 add1) 3) 3)
  (check-true ((conjoin positive? integer?) 5))
  (check-false ((conjoin positive? integer?) -5))
  (check-false ((conjoin bytes<? bytes=?) #"apple" #"banana"))
  (check-true ((disjoin positive? integer?) 5))
  (check-true ((disjoin positive? integer?) -5))
  (check-true ((disjoin positive? integer?) 5.3))
  (check-false ((disjoin positive? integer?) -5.3))
  (check-true ((disjoin bytes<? bytes=?) #"apple" #"banana"))
  ;; custom composition
  (check-true ((function (list positive? integer? (curryr > -3))
                         (λ (f g)
                           (λ (x)
                             (xor (f x)
                                  (g x))))
                         (const #f)
                         'left
                         empty-arguments)
               5))
  (check-false ((function (list positive? integer? (curryr > -3))
                          (λ (f g)
                            (λ (x)
                              (xor (f x)
                                   (g x))))
                          (const #f)
                          'left
                          empty-arguments)
                -1))
  (check-true ((function (list positive? integer? (curryr > -3))
                         (λ (f g)
                           (λ (x)
                             (xor (f x)
                                  (g x))))
                         (const #f)
                         'left
                         empty-arguments)
               -1.4))
  (check-false ((function (list positive? integer? (curryr > -3))
                          (λ (f g)
                            (λ (x)
                              (xor (f x)
                                   (g x))))
                          (const #f)
                          'left
                          empty-arguments)
                -3.4)))
