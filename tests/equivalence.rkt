#lang racket/base

(module+ test
  (require rackunit
           relation
           (prefix-in b: racket/base)
           racket/set
           racket/stream
           racket/sequence
           racket/function)

  ;; equal / equivalence
  (check-false (= 1 2 3) "monotonically increasing")
  (check-false (= 1 1 2) "monotonically nondecreasing")
  (check-true (= 3 3 3) "equal")
  (check-false (= 3 3 1) "monotonically nonincreasing")
  (check-false (= 3 2 1) "monotonically decreasing")
  (check-false (= 3 2 4) "disordered")
  (check-true (= 3) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (=)) "generic relations require at least one argument")
  (check-false (= 3 (void)) "non-uniform types")
  (check-false (= "apple" "banana" "cherry"))
  (check-true (= "apple" "apple" "apple"))
  (check-false (= "cherry" "banana" "apple"))
  (check-false (= #"apple" #"banana" #"cherry"))
  (check-true (= #"apple" #"apple" #"apple"))
  (check-false (= #"cherry" #"banana" #"apple"))
  (check-false (= #\a #\b #\c))
  (check-true (= #\a #\a #\a))
  (check-false (= #\c #\b #\a))
  (check-false (= (set) (set 1) (set 1 2)))
  (check-true (= (set 1 2) (set 1 2) (set 1 2)))
  (check-false (= (set 1 2) (set 1) (set)))
  (check-false (= (set 1 2) (set 1 3)) "incomparable sets")
  (check-false (= (set 1 2) (set 3 4)) "incomparable sets")
  (check-false (= #:key string-length "z" "yy" "xxx"))
  (check-true (= #:key string-length "xxx" "zzz" "yyy"))
  (check-false (= #:key string-length "xxx" "yy" "z"))

  ;; simple type-specific equality
  (check-true (= 'hi 'hi 'hi))

  ;; custom types
  ((λ ()
     (struct amount (dollars cents)
       #:transparent
       #:methods gen:comparable
       [(define (equal? comparable other)
          (= (amount-dollars comparable)
             (amount-dollars other)))])
     (check-true (= (amount 5 95) (amount 5 99)))
     (check-false (= (amount 5 95) (amount 4 95)))))

  ;; equivalence under a mapping
  (check-true (= #:key identity 1 1 1))
  (check-true (= #:key even? 1 13 7))
  (check-true (= #:key even? 2 14 8))
  (check-false (= #:key even? 2 3))
  (check-true (= #:key string-upcase "apple" "Apple" "APPLE"))
  (check-true (= #:key ->number "42" "42.0" "42/1"))
  (check-false (= #:key ->number "42" "42.1"))

  ;; not equal
  (check-true (≠ 1 2 3) "monotonically increasing")
  (check-true (≠ 1 1 2) "monotonically nondecreasing")
  (check-false (≠ 3 3 3) "equal")
  (check-true (≠ 3 3 1) "monotonically nonincreasing")
  (check-true (≠ 3 2 1) "monotonically decreasing")
  (check-true (≠ 3 2 4) "disordered")
  (check-false (≠ 3) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (≠)) "generic relations require at least one argument")
  (check-true (≠ "apple" "banana" "cherry"))
  (check-false (≠ "apple" "apple" "apple"))
  (check-true (≠ "cherry" "banana" "apple"))
  (check-true (≠ #"apple" #"banana" #"cherry"))
  (check-false (≠ #"apple" #"apple" #"apple"))
  (check-true (≠ #"cherry" #"banana" #"apple"))
  (check-true (≠ #\a #\b #\c))
  (check-false (≠ #\a #\a #\a))
  (check-true (≠ #\c #\b #\a))
  (check-true (≠ (set) (set 1) (set 1 2)))
  (check-false (≠ (set 1 2) (set 1 2) (set 1 2)))
  (check-true (≠ (set 1 2) (set 1) (set)))
  (check-true (≠ (set 1 2) (set 1 3)) "incomparable sets")
  (check-true (≠ (set 1 2) (set 3 4)) "incomparable sets")
  (check-true (≠ #:key string-length "z" "yy" "xxx"))
  (check-false (≠ #:key string-length "xxx" "zzz" "yyy"))
  (check-true (≠ #:key string-length "xxx" "yy" "z"))
  (check-false (/= 2 2))
  (check-true (/= 3 2))

  (check-true (≠ "apple" "Apple"))
  (check-true (≠ 'a 'b))
  (check-false (≠ 'a 'a))

  ;; group-by
  (check-equal? (->set (group-by (list 1 2 3))) (->set '((1) (2) (3))) "monotonically increasing")
  (check-equal? (->set (group-by (list 1 1 2))) (->set '((1 1) (2))) "monotonically nondecreasing")
  (check-equal? (->set (group-by (list 3 3 3))) (->set '((3 3 3))) "equal")
  (check-equal? (->set (group-by (list 3 3 1))) (->set '((1) (3 3))) "monotonically nonincreasing")
  (check-equal? (->set (group-by (list 3 2 1))) (->set '((1) (2) (3))) "monotonically decreasing")
  (check-equal? (->set (group-by (list 3 2 4))) (->set '((2) (3) (4))) "disordered")
  (check-equal? (->set (group-by (list 3))) (->set '((3))) "trivial case")
  (check-exn exn:fail?
             (lambda ()
               (group-by)) "generic relations require at least one argument")
  (check-equal? (->set (group-by (list "apple" "banana" "cherry"))) (->set '(("apple") ("banana") ("cherry"))))
  (check-equal? (->set (group-by (list "apple" "apple" "apple"))) (->set '(("apple" "apple" "apple"))))
  (check-equal? (->set (group-by (list "cherry" "banana" "apple"))) (->set '(("apple") ("banana") ("cherry"))))
  (check-equal? (->set (group-by (list #"apple" #"banana" #"cherry"))) (->set '((#"apple") (#"banana") (#"cherry"))))
  (check-equal? (->set (group-by (list #"apple" #"apple" #"apple"))) (->set '((#"apple" #"apple" #"apple"))))
  (check-equal? (->set (group-by (list #"cherry" #"banana" #"apple"))) (->set '((#"apple") (#"banana") (#"cherry"))))
  (check-equal? (->set (group-by (list #\a #\b #\c))) (->set '((#\a) (#\b) (#\c))))
  (check-equal? (->set (group-by (list #\a #\a #\a))) (->set '((#\a #\a #\a))))
  (check-equal? (->set (group-by (list #\c #\b #\a))) (->set '((#\a) (#\b) (#\c))))
  (check-equal? (->set (group-by (list (set) (set 1) (set 1 2)))) (set (list (set)) (list (set 1)) (list (set 1 2))))
  (check-equal? (->set (group-by (list (set 1 2) (set 1 2) (set 1 2)))) (set (list (set 1 2) (set 1 2) (set 1 2))))
  (check-equal? (->set (group-by (list (set 1 2) (set 1) (set)))) (set (list (set)) (list (set 1)) (list (set 1 2))))
  (check-equal? (->set (group-by (list (set 1 2) (set 1 3)))) (set (list (set 1 2)) (list (set 1 3))) "incomparable sets")
  (check-equal? (->set (group-by (list (set 1 2) (set 3 4)))) (set (list (set 1 2)) (list (set 3 4))) "incomparable sets")
  (check-equal? (->set (group-by #:key string-length (list "z" "yy" "xxx"))) (->set '(("z") ("yy") ("xxx"))))
  (check-equal? (->set (group-by #:key string-length (list "xxx" "zzz" "yyy"))) (->set '(("xxx" "zzz" "yyy"))))
  (check-equal? (->set (group-by #:key string-length (list "xxx" "yy" "z"))) (->set '(("z") ("yy") ("xxx"))))
  (check-equal? (->set (group-by #:key odd? (list 2 3 4 5 7))) (->set '((2 4) (3 5 7))))

  ;; generic-set
  (check-equal? (->set (generic-set 1 2 3)) (set 1 2 3) "monotonically increasing")
  (check-equal? (->set (generic-set 1 1 2)) (set 1 2) "monotonically nondecreasing")
  (check-equal? (->set (generic-set 3 3 3)) (set 3) "equal")
  (check-equal? (->set (generic-set 3 3 1)) (set 1 3) "monotonically nonincreasing")
  (check-equal? (->set (generic-set 3 2 1)) (set 1 2 3) "monotonically decreasing")
  (check-equal? (->set (generic-set 3 2 4)) (set 2 3 4) "disordered")
  (check-equal? (->set (generic-set 3)) (set 3) "trivial case")
  (check-equal? (->set (generic-set)) (set) "empty set OK")
  (check-equal? (->set (generic-set "apple" "banana" "cherry")) (set "apple" "banana" "cherry"))
  (check-equal? (->set (generic-set "apple" "apple" "apple")) (set "apple"))
  (check-equal? (->set (generic-set "cherry" "banana" "apple")) (set "apple" "banana" "cherry"))
  (check-equal? (->set (generic-set #"apple" #"banana" #"cherry")) (set #"apple" #"banana" #"cherry"))
  (check-equal? (->set (generic-set #"apple" #"apple" #"apple")) (set #"apple"))
  (check-equal? (->set (generic-set #"cherry" #"banana" #"apple")) (set #"apple" #"banana" #"cherry"))
  (check-equal? (->set (generic-set #\a #\b #\c)) (set #\a #\b #\c))
  (check-equal? (->set (generic-set #\a #\a #\a)) (set #\a))
  (check-equal? (->set (generic-set #\c #\b #\a)) (set #\a #\b #\c))
  (check-equal? (->set (generic-set (set) (set 1) (set 1 2))) (set (set) (set 1) (set 1 2)))
  (check-equal? (->set (generic-set (set 1 2) (set 1 2) (set 1 2))) (set (set 1 2)))
  (check-equal? (->set (generic-set (set 1 2) (set 1) (set))) (set (set) (set 1) (set 1 2)))
  (check-equal? (->set (generic-set (set 1 2) (set 1 3))) (set (set 1 2) (set 1 3)) "incomparable sets")
  (check-equal? (->set (generic-set (set 1 2) (set 3 4))) (set (set 1 2) (set 3 4)) "incomparable sets")
  (check-equal? (->set (generic-set #:key string-length "z" "yy" "xxx")) (set "z" "yy" "xxx"))
  (check-equal? (->set (generic-set #:key string-length "xxx" "zzz" "yyy")) (set "xxx"))
  (check-equal? (->set (generic-set #:key string-length "xxx" "yy" "z")) (set "z" "yy" "xxx")))
